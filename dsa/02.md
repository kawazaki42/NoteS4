будем строить графики

LLM работают в O(n^2)


omega - нижняя граница

theta - асимптота

{worst, average, best} case

самый популярный - average case

повторные числа иногда собираются в начало!

# Space complexity

- пооперационный анализ
  - считать каждую элементарную операцию по времени
- метод Гиббсона
- вручную посчитать время

а еще на маленьком времени все очень колеблется

ждем минуты или десятки секунд

берем точек 4-10

- total (wall time) - сколько фактически времени прошло
- system - время на системные вызовы (к ОС)
- user - остальное

использование проца: если > 100% то это многоядерка

чем меньше l - тем спидознее память

время доступа в разных ячейках одинаково

Кэш-линия

Без особой необходимости по массиву не прыгаем!

а то кэш неэффективен будет

глубина рекурсии - кол-во вложенных вызовов

шаг рекурсии - способ разбиения задачи

терминальная ветвь - она же base case

```c++
// вычислить факрториал

// 5! = 1 * 2 * 3 * 4 * 5
// 5! = 4! * 5

/// Вычисляет факториал числа
long long fact(long long n) {
    if(n == 0 || n == 1) {  // терминальная ветвь
        return 1;
    } else {  // рекурсивная ветвь
        return fact(n-1) * n;
    }
}

int main() {
    assert(fact(0) == 1);
    assert(fact(1) == 1);
    assert(fact(3) == 6);
    assert(fact(9) == 362880);
}
```

прямой и обратный ход рекурсии

выяснить предел стека

с отладкой и без отладки
